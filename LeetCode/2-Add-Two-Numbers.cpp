/*
  Author: Xueyang Liu
  Date: 2018/01/25

*/

// ==================================================

//                                        /*
//                                       +
//                                      +
//                                     +
//                                     +
//                                     [         >i>n[t
//                                      */   #include<stdio.h>
//                         /*2w0,1m2,]_<n+a m+o>r>i>=>(['0n1'0)1;
//                      */int/**/main(int/**/n,char**m){FILE*p,*q;int        A,k,a,r,i/*
//                    #uinndcelfu_dset<rsitcdti_oa.nhs>i/_*/;char*d="P%"   "d\n%d\40%d"/**/
//                  "\n%d\n\00wb+",b[1024],y[]="yuriyurarararayuruyuri*daijiken**akkari~n**"
//           "/y*u*k/riin<ty(uyr)g,aur,arr[a1r2a82*y2*/u*r{uyu}riOcyurhiyua**rrar+*arayra*="
//        "yuruyurwiyuriyurara'rariayuruyuriyuriyu>rarararayuruy9uriyu3riyurar_aBrMaPrOaWy^?"
//       "*]/f]`;hvroai<dp/f*i*s/<ii(f)a{tpguat<cahfaurh(+uf)a;f}vivn+tf/g*`*w/jmaa+i`ni("/**
//      */"i+k[>+b+i>++b++>l[rb";int/**/u;for(i=0;i<101;i++)y[i*2]^="~hktrvg~dmG*eoa+%squ#l2"
//      ":(wn\"1l))v?wM353{/Y;lgcGp`vedllwudvOK`cct~[|ju {stkjalor(stwvne\"gt\"yogYURUYURI"[
//      i]^y[i*2+1]^4;/*!*/p=(n>1&&(m[1][0]-'-'||m[1][1]  !='\0'))?fopen(m[1],y+298):stdin;
//       /*y/riynrt~(^w^)],]c+h+a+r+*+*[n>)+{>f+o<r<(-m]    =<2<5<64;}-]-(m+;yry[rm*])/[*
//        */q=(n<3||!(m[2][0]-'-'||m[2][1]))?stdout /*]{     }[*/:fopen(m[2],d+14);if(!p||/*
//        "]<<*-]>y++>u>>+r >+u+++y>--u---r>++i+++"  <)<      ;[>-m-.>a-.-i.++n.>[(w)*/!q/**/)
//     return+printf("Can "  "not\x20open\40%s\40"    ""       "for\40%sing\n",m[!p?1:2],!p?/*
//   o=82]5<<+(+3+1+&.(+  m  +-+1.)<)<|<|.6>4>-+(>    m-        &-1.9-2-)-|-|.28>-w-?-m.:>([28+
//  */"read":"writ");for  (   a=k=u= 0;y[u];  u=2    +u){y[k++   ]=y[u];}if((a=fread(b,1,1024/*
// ,mY/R*Y"R*/,p/*U*/)/*          R*/ )>/*U{  */   2&& b/*Y*/[0]/*U*/=='P' &&4==/*"y*r/y)r\}
// */sscanf(b,d,&k,& A,&           i,  &r)&&        !   (k-6&&k -5)&&r==255){u=A;if(n>3){/*
// ]&<1<6<?<m.-+1>3> +:+ .1>3+++     .   -m-)      -;.u+=++.1<0< <; f<o<r<(.;<([m(=)/8*/
// u++;i++;}fprintf   (q,    d,k,           u      >>1,i>>1,r);u  = k-5?8:4;k=3;}else
//   /*]>*/{(u)=/*{   p> >u  >t>-]s                >++(.yryr*/+(    n+14>17)?8/4:8*5/
//      4;}for(r=i=0  ;  ;){u*=6;u+=                (n>3?1:0);if    (y[u]&01)fputc(/*
//       <g-e<t.c>h.a r  -(-).)8+<1.                 >;+i.(<)<     <)+{+i.f>([180*/1*
//       (r),q);if(y[u   ]&16)k=A;if                               (y[u]&2)k--;if(i/*
//       ("^w^NAMORI; {   I*/==a/*"                               )*/){/**/i=a=(u)*11
//        &255;if(1&&0>=     (a=                                 fread(b,1,1024,p))&&
//         ")]i>(w)-;} {                                         /i-f-(-m--M1-0.)<{"
//          [ 8]==59/* */                                       )break;i=0;}r=b[i++]
//             ;u+=(/**>>                                     *..</<<<)<[[;]**/+8&*
//             (y+u))?(10-              r?4:2):(y[u]         &4)?(k?2:4):2;u=y[u/*
//              49;7i\(w)/;}             y}ru\=*ri[        ,mc]o;n}trientuu ren (
//              */]-(int)'`';}             fclose(          p);k= +fclose( q);
//               /*] <*.na/m*o{ri{                       d;^w^;}  }^_^}}
//                "   */   return  k-                -1+   /*\'   '-`*/
//                      (   -/*}/   */0x01        );       {;{    }}
//                             ;           /*^w^*/        ;}

// ==================================================

// C library
#include <cmath>
#include <climits>
#include <cstdio>
#include <cstdlib>
#include <cstring>

// Containers
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>

// Input/Output
#include <iostream>
#include <istream>
#include <ostream>
#include <sstream>
#include <fstream>
#include <ios>
#include <iomanip>

// Other
#include <tuple>
#include <string>
#include <tuple>
#include <bitset>
#include <algorithm>
#include <utility>
#include <type_traits>
#include <iterator>
#include <limits>

// ==================================================

using namespace std;

using PII = pair<int, int>;

using MII = map<int, int>;
using UMII = unordered_map<int, int>;

using SI = set<int>;
using USI = unordered_set<int>;

using VC = vector<char>;
using VVC = vector<vector<char>>;

using VI = vector<int>;
using VVI = vector<vector<int>>;

using VD = vector<double>;
using VVD = vector<vector<double>>;

using VS = vector<string>;
using VVS = vector<vector<string>>;

using VPII = vector<PII>;

// ==================================================

static auto __________2333__________ = []() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  return 0;
}();

// ==================================================

template<typename T>
void PRINT_CONTAINER(const T& c) {
  for (auto x : c) cout << x << " ";
  cout << "\n";
}

template<typename T>
void PRINTV(const vector<T>& c) {
  PRINT_CONTAINER<vector<T>>(c);
}

template<typename T1, typename T2>
void PRINTP(const pair<T1, T2>& p) {
  PRINTC(p.first);
  PRINTLN(p.second);
}

template<typename T>
void PRINTC(const T& a) {
  cout << a << " ";
}

template<typename T>
void PRINTLN(const T& a) {
  cout << a << "\n";
}

template<typename T1, typename T2>
auto max_(const T1& a, const T2& b) {
  using return_type = decltype(a + b);
  return a > b ? static_cast<return_type>(a) : static_cast<return_type>(b);
}

// ==================================================

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
};

class Solution1 {
public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    if (nullptr == l1 || nullptr == l2) return nullptr;

    ListNode *head { nullptr }, *cur { nullptr };
    int tmp { 0 }, inc { 0 };

    while (nullptr != l1 && nullptr != l2) {
      tmp = l1->val + l2->val + inc;
      inc = tmp / 10;
      tmp = tmp % 10;
      ListNode* node_ptr { new ListNode(tmp) };

      if (nullptr == head) head = node_ptr;
      if (nullptr != cur) cur->next = node_ptr;

      cur = node_ptr;
      l1 = l1->next;
      l2 = l2->next;
    }

    auto rest = [&](ListNode* h) {
      while (nullptr != h) {
	tmp = h->val + inc;
	inc = tmp / 10;
	tmp = tmp % 10;
	ListNode *node_ptr { new ListNode(tmp) };
	cur->next = node_ptr;
	cur = node_ptr;
	h = h->next;
      }
    };

    if (nullptr != l1) rest(l1);
    if (nullptr != l2) rest(l2);

    if (0 != inc) {
      ListNode *node_ptr { new ListNode(inc) };
      cur->next = node_ptr;
    }

    return head;
  }
};

class Solution2 {
public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode *head = new ListNode(0);
    ListNode *tail = head;

    int carry = 0;
    while(l1 || l2 || carry){
      int n = (l1?l1->val:0) + (l2?l2->val:0) + carry;
      tail -> next = new ListNode(n % 10);
      carry = n / 10;
      tail = tail -> next;
      l1 = l1?l1 -> next:NULL;
      l2 = l2?l2 -> next:NULL;
    }
    return head -> next;
  }
};



class Solution {
public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode *head { nullptr }, *tail = head;
    int inc { 0 }, tmp;

    while (l1 || l2 || inc) {
      tmp = (nullptr == l1 ? 0 : l1->val) + (nullptr == l2 ? 0 : l2->val) + inc;
      inc = tmp / 10;
      ListNode *cur { new ListNode(tmp % 10) };
      head = (nullptr == head ? cur : head);
      if (nullptr != tail) tail->next = cur;
      tail = cur;
      l1 = (nullptr == l1 ? nullptr : l1->next);
      l2 = (nullptr == l2 ? nullptr : l2->next);
    }

    return head;
  }
};


int main(void) {

  return 0;
}
